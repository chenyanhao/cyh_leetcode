package p001_p100.p031下一个排列;

import java.util.Arrays;

/**
 * 该题分两部分看，
 * 1）下一个数比当前数大。
 * 2）下一个数增加的幅度尽可能的小。
 *
 * 对于第一点，只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。例如123，交换3和1就能得到一个更大的数 312。
 * 对于第二点，需要「大数」尽可能小、而「小数」尽可能大。需要这样保证，
 * 1）在尽可能靠右的低位进行交换，因此需要从后向前查找
 * 2）找到的满足条件的「大数」要尽可能的小，例如123465，应该交换5和4，而不是6和4交换，即「大数」是5而不是6
 * 3）将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，因为升序排列才是最小的排列。
 *  例如123465，应该交换5和4后得到123564，然后需要将5后面的64重置为升序，得到123546，这样才是最小的排列。
 *
 * 以 12385764 为例，推演求解过程，
 * 1）从最右边，也就是4开始，往前找到第一个相邻的升序对(5, 7)，此时5就是「小数」
 * 2）再从最右边开始，在子串 764 中，找到第一个大于 5 的元素6，此时6就是「大数」
 * 3）交换5和6，得到12386754，同时将754变成升序，即457，就得到最终结果1236457
 *
 * 算法过程可以描述为：
 * 1）从后向前找到第一个相邻升序的元素对 (nums[i], nums[i+1])，满足 nums[i] < nums[i+1]。如果没找到，则直接逆序数组即可结束流程。
 * 2）如果找到了，在 [i+1, len-1] 中从后往前找到第一个比 nums[i] 大的数 nums[j]
 * 3) 交换 nums[i]和nums[j]
 * 4）对 [i+1, len-1] 升序排列
 *
 */
class Solution {
    public void nextPermutation(int[] nums) {
        // 从右侧开始，找递增对
        int n = nums.length - 1;
        for (int i = n - 1; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                // 找到 i 后面，比 i 大，但是又最接近它的值的下标
                int j = n;
                while (j > i && nums[j] <= nums[i]) {
                    --j;
                }
                swap(nums, i, j);
                Arrays.sort(nums, i + 1, nums.length);
                return;
            }
        }
        Arrays.sort(nums, 0, nums.length);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
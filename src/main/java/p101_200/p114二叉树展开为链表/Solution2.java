package p101_200.p114二叉树展开为链表;

/**
 * 考虑这样一个思路，利用先序遍历的代码，每遍历一个节点，就将上一个节点的右指针更新为当前节点。
 * 举例来说，
 *     1
 *    / \
 *   2   5
 *  / \   \
 * 3   4   6
 * 1）先序遍历的顺序是 [1 2 3 4 5 6]。
 * 2）遍历到 2，把 1 的右指针指向 2。即，[1->2  3 4 5 6]。
 * 3）遍历到 3，把 2 的右指针指向 3。即，[1->2->3 4 5 6]。
 * 但实际行不通，原因就是把 1 的右指针指向 2，1 的原本的右孩子就丢失了，也就是 5 就找不到了。
 *
 *
 * 所以解决办法就是过来，即 [6 5 4 3 2 1]。
 * 1）遍历到 5，把 5 的右指针指向 6。[6<-5  4 3 2 1]。
 * 2）遍历到 4，把 4 的右指针指向 5。[6<-5<-4 3 2 1]。
 *
 * 这样就不会有丢失孩子的问题了，因为更新当前的右指针的时候，当前节点的右孩子已经访问过了。
 *
 * 而 [6 5 4 3 2 1] 的遍历顺序其实变形的后序遍历，遍历顺序是右子树->左子树->根节点。
 *
 */
class Solution2 {

    private TreeNode pre = null;

    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }

        flatten(root.right);
        flatten(root.left);

        root.right = pre;
        root.left = null;

        pre = root;
    }

}